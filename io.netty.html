<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Netty</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>p>code{color: #d14 !important;background-color: #f5f5f5 !important;border: 1px solid #e1e1e8;white-space: nowrap;border-radius: 3px;}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Netty</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_jdk_原生_socket_编程">1. JDK 原生 Socket 编程</a></li>
<li><a href="#_server_startup">2. Server startup</a></li>
<li><a href="#_nioeventloop">3. <code>NioEventLoop</code></a></li>
<li><a href="#_netty">4. Netty</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Netty 和 <code>ServerSocketChannel</code> 可以互相操作吗？</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jdk_原生_socket_编程"><a class="anchor" href="#_jdk_原生_socket_编程"></a>1. JDK 原生 Socket 编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用 JDK 原生的 Socket API 进行网络编程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty;

import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.locks.LockSupport;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-04-21 14:31
 */
public class ServerSocketTest {
    public static final String HOST = "127.0.0.1";
    public static final int PORT = 11911;

    @Test
    public void testServer() {
        Server server = new Server(PORT);
        server.start();
        LockSupport.park();
    }

    @Test
    public void testClient() throws IOException {
        Socket socket = new Socket(HOST, PORT);
        new Thread(() -&gt; {
            System.out.println("客户端启动成功");
            while (true) {
                try {
                    String message = "Hello, D瓜哥！";
                    System.out.println("客户端发送数据：" + message);
                    socket.getOutputStream().write(message.getBytes(UTF_8));
                } catch (IOException e) {
                    System.out.println("写入数据报错！");
                    e.printStackTrace();
                }
                sleep();
            }
        }).start();
        LockSupport.park();
    }

    private void sleep() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static class Server {
        private ServerSocket serverSocket;

        public Server(int port) {
            try {
                this.serverSocket = new ServerSocket(port);
                System.out.println("服务端启动成功，端口号：" + port);
            } catch (IOException e) {
                System.out.println("服务端启动失败");
                e.printStackTrace();
            }
        }

        public void start() {
            new Thread(() -&gt; doStart()).start();
        }

        private void doStart() {
            while (true) {
                try {
                    Socket socket = serverSocket.accept();
                    new ClientHandler(socket).start();
                } catch (IOException e) {
                    System.out.println("服务端异常");
                    e.printStackTrace();
                }
            }
        }
    }

    private static class ClientHandler {
        public static final int MAX_DATA_LEN = 1024;
        private final Socket socket;

        public ClientHandler(Socket socket) {
            this.socket = socket;
        }

        public void start() {
            System.out.println("新客户端接入");
            new Thread(() -&gt; doStart()).start();
        }

        private void doStart() {
            try {
                InputStream inputStream = socket.getInputStream();
                while (true) {
                    byte[] data = new byte[MAX_DATA_LEN];
                    int len;
                    while ((len = inputStream.read(data)) != -1) {
                        String message = new String(data, 0, len);
                        System.out.println("客户端传来消息：" + message);
                        socket.getOutputStream().write(data);
                    }
                }
            } catch (IOException e) {
                System.out.println("服务端读取错误失败");
                e.printStackTrace();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>阻塞</p>
</li>
<li>
<p>高性能</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_server_startup"><a class="anchor" href="#_server_startup"></a>2. Server startup</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty;

import io.netty.bootstrap.Bootstrap;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.util.AttributeKey;
import org.junit.Test;

import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.concurrent.locks.LockSupport;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-04-20 22:19
 */
public class Test03 {
    private static final int PORT = 11911;

    @Test
    public void testServer() throws InterruptedException {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childOption(ChannelOption.TCP_NODELAY, true)
                    .childAttr(AttributeKey.newInstance("childAttr"), null)
                    .handler(new ServerHandler())
                    .childHandler(new ChannelInitializer&lt;&gt;() {
                        @Override
                        protected void initChannel(Channel ch) throws Exception {

                        }
                    });
            ChannelFuture f = b.bind(PORT).sync();
            f.addListener(future -&gt; {
                if (future.isSuccess()) {
                    System.out.println(LocalDateTime.now() + ": 端口[" + PORT + "]绑定成功！");
                } else {
                    System.out.println(LocalDateTime.now() + ": 端口[" + PORT + "]绑定失败！");
                }
            });
            f.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
        LockSupport.park();
    }

    public static class ServerHandler extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
            System.out.println("channelRegistered");
        }

        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
            System.out.println("channelActive");
        }

        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            System.out.println("handlerAdded");
        }

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
//            ((ByteBuf) msg).release();
//            ReferenceCountUtil.release(msg);
            ctx.write(msg);
            ctx.flush();
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            cause.printStackTrace();
            ctx.close();
        }
    }

    @Test
    public void testClient() throws InterruptedException {
        NioEventLoopGroup executors = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(executors)
                    .channel(NioSocketChannel.class)
                    .remoteAddress(new InetSocketAddress("localhost", PORT))
                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new ClientHandler());
                        }
                    });
        } finally {
            executors.shutdownGracefully().sync();
        }
    }

    public static class ClientHandler extends ChannelInboundHandlerAdapter {
        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            System.out.println("Handl");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个问题</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>服务端的 Socket 在哪里初始化？</p>
</li>
<li>
<p>在哪里 accept 连接？</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Netty 服务端启动</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建服务端 <code>Channel</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>io.netty.bootstrap.AbstractBootstrap.bind(int)</code></p>
</li>
<li>
<p><code>io.netty.bootstrap.AbstractBootstrap.doBind(SocketAddress)</code></p>
</li>
<li>
<p><code>io.netty.bootstrap.AbstractBootstrap.initAndRegister()</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>初始化服务端 <code>Channel</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>NioServerSocketChannel.NioServerSocketChannel()</code> 在 <code>NioServerSocketChannel</code> 默认初始化函数中，使用了 JDK 内置的 <code>SelectorProvider.provider()</code> 方法返回的 <code>SelectorProvider</code> 对象。</p>
</li>
<li>
<p>在 <code>NioServerSocketChannel.newSocket(SelectorProvider)</code> 方法中，调用 <code>provider.openServerSocketChannel()</code> 来创建 <code>ServerSocketChannel</code> 对象。</p>
</li>
<li>
<p>在 <code>AbstractNioChannel.AbstractNioChannel(Channel, SelectableChannel, int)</code> 构造函数中，设置 <code>selectableChannel.configureBlocking(false)</code>。</p>
</li>
</ol>
</div>
</li>
<li>
<p>注册 Selector</p>
</li>
<li>
<p>端口绑定&#8201;&#8212;&#8201;调用底层 API，实现对端口的绑定。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>服务端 <code>Channel</code> 初始化过程</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 <code>bind()</code> 进入</p>
</li>
<li>
<p><code>initAndRegister()</code></p>
</li>
<li>
<p>在 <code>AbstractBootstrap.initAndRegister()</code> 中通过 <code>channelFactory.newChannel()</code> 利用反射机制来创建 <code>Channel</code>。</p>
</li>
<li>
<p>在 <code>ServerBootstrap.init(Channel)</code> 中，初始化 <code>Channel</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>setChannelOptions</code></p>
</li>
<li>
<p><code>setAttributes</code></p>
</li>
<li>
<p>配置 <code>ChannelHandler</code>&#8201;&#8212;&#8201;配置服务端 pipeline。</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>初始化时，调用 <code>AbstractBootstrap.handler(io.netty.channel.ChannelHandler)</code>，配置 <code>ChannelHandler</code> 对象</p>
</li>
<li>
<p>通过调用 <code>AbstractBootstrap.initAndRegister()</code> 方法调用 <code>ServerBootstrap.init(Channel)</code> 方法，在其中，将 <code>ChannelHandler</code> 对象追加到 <code>Channel</code> 对象的 pipeline 的最后面。</p>
</li>
</ol>
</div>
</li>
<li>
<p>add <code>ServerBootstrapAcceptor</code></p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>上一步执行完毕后，在 <code>ServerBootstrap.init(Channel)</code> 方法中，会创建一个 <code>ServerBootstrapAcceptor</code> 对象添加到 pipeline 后面。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>注册 selector</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>AbstractChannel.AbstractUnsafe.register(EventLoop, ChannelPromise)</code> 入口</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>AbstractChannel.this.eventLoop = eventLoop;</code> 绑定线程</p>
</li>
<li>
<p><code>AbstractChannel.AbstractUnsafe.register0(ChannelPromise)</code> 实际注册</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p><code>AbstractChannel.doRegister()</code> 调用底层 JDK API 注册</p>
</li>
<li>
<p><code>pipeline.invokeHandlerAddedIfNeeded()</code></p>
</li>
<li>
<p><code>pipeline.fireChannelRegistered()</code></p>
<div class="paragraph">
<p>从示例代码的输出可以看出，<code>Test03.ServerHandler</code> 中三个"事件"方法被调用的顺序是： <code>handlerAdded</code>，<code>channelRegistered</code> 和 <code>channelActive</code>。</p>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>端口绑定</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>AbstractChannel.AbstractUnsafe.bind(SocketAddress, ChannelPromise)</code> 入口</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>AbstractBootstrap.doBind(SocketAddress)</code></p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p><code>javaChannel().bind()</code> JDK 底层绑定 <code>io.netty.channel.AbstractChannel.AbstractUnsafe.bind</code></p>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>` pipeline.fireChannelActive()` 传播事件</p>
</li>
</ol>
</div>
</li>
<li>
<p><code>HeadContext.readIfIsAutoRead()</code></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nioeventloop"><a class="anchor" href="#_nioeventloop"></a>3. <code>NioEventLoop</code></h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>默认情况下，Netty 服务端起多少个线程？何时启动？</p>
</li>
<li>
<p>Netty 是如何解决 JDK 空轮询 Bug 的？</p>
</li>
<li>
<p>Netty 如何保证异步串行无锁化？</p>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>NioEventLoop</code> 创建</p>
</li>
<li>
<p><code>NioEventLoop</code> 启动</p>
</li>
<li>
<p><code>NioEventLoop</code> 执行逻辑</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_nioeventloop_创建"><a class="anchor" href="#_nioeventloop_创建"></a>3.1. <code>NioEventLoop</code> 创建</h3>
<div class="paragraph">
<p><code>NioEventLoop</code> 默认是在调用 <code>NioEventLoopGroup()</code> 时被创建，默认是 2 倍的 CPU 数量（由常量 <code>MultithreadEventLoopGroup.DEFAULT_EVENT_LOOP_THREADS</code> 来定义）。</p>
</div>
<div class="paragraph">
<p>在 <code>MultithreadEventExecutorGroup.MultithreadEventExecutorGroup(int, Executor, EventExecutorChooserFactory, Object&#8230;&#8203;)</code> 构造函数中：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建 <code>new ThreadPerTaskExecutor(newDefaultThreadFactory())</code> 线程池；</p>
<div class="paragraph">
<p>每次执行任务都会创建一个线程实体。</p>
</div>
<div class="paragraph">
<p><code>NioEventLoop</code> 线程命名规则 <code>nioEventLoop-1-XX</code>。在 <code>io.netty.util.concurrent.DefaultThreadFactory</code> 中可以看到。</p>
</div>
<div class="paragraph">
<p>这里还有两点需要注意：创建的线程对象和 <code>Runable</code> 被分别包装成了 <code>FastThreadLocalThread</code> 和 <code>FastThreadLocalRunnable</code>，主要是对 <code>ThreadLocal</code> 做了一些优化。</p>
</div>
</li>
<li>
<p>使用 <code>for</code> 循环，利用 <code>MultithreadEventExecutorGroup.newChild(Executor, Object&#8230;&#8203;)</code> 方法创建 <code>NioEventLoop</code> 对象。</p>
<div class="paragraph">
<p>有三个作用：①保存线程执行器 <code>ThreadPerTaskExecutor</code>；②创建一个 <code>MpscQueue</code>；③创建一个 selector。</p>
</div>
<div class="paragraph">
<p>在 <code>NioEventLoop.newTaskQueue(int)</code> 方法，然后调用 <code>NioEventLoop.newTaskQueue0(int)</code> 方法，创建 <code>MpscQueue</code>。</p>
</div>
</li>
<li>
<p>调用 <code>DefaultEventExecutorChooserFactory.newChooser(EventExecutor[])</code> 方法，创建线程选择器。</p>
<div class="paragraph">
<p><code>isPowerOfTwo()</code> 判断是否是 2 的幂，如果是则返回 <code>PowerOfTwoEventExecutorChooser</code>（优化），返回 <code>index &amp; (length - 1)`；否则返回 `GenericEventExecutorChooser`（普通），返回 `abs(index % length)</code>。</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_nioeventloop_启动"><a class="anchor" href="#_nioeventloop_启动"></a>3.2. <code>NioEventLoop</code> 启动</h3>
<div class="ulist">
<ul>
<li>
<p>服务端启动绑定接口</p>
</li>
<li>
<p>新连接接入，通过 choose 绑定一个 <code>NioEventLoop</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 <code>AbstractBootstrap.doBind0</code> 方法中，调用 <code>SingleThreadEventExecutor.execute(java.lang.Runnable)</code> 开始启动，再调用 <code>SingleThreadEventExecutor.execute(java.lang.Runnable, boolean)</code>，最后通过 <code>SingleThreadEventExecutor.startThread</code> 方法来启动。实际启动工作，最后委托给了 <code>SingleThreadEventExecutor.doStartThread</code> 方法来执行，这个方法中，调用 <code>SingleThreadEventExecutor.this.run();</code> 来启动 <code>NioEventLoop</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_nioeventloop_执行逻辑"><a class="anchor" href="#_nioeventloop_执行逻辑"></a>3.3. <code>NioEventLoop</code> 执行逻辑</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>run() &#8594; for(;;)</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>select()</code> 检查是否有 I/O 事件</p>
</li>
<li>
<p><code>processSelectedKeys()</code> 处理 I/O 事件</p>
</li>
<li>
<p><code>SingleThreadEventExecutor.runAllTasks(long)</code> 处理异步任务队列</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>select() 方法</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>deadline 以及任务穿插逻辑处理</p>
<div class="paragraph">
<p><code>NioEventLoop.select(long)</code></p>
</div>
</li>
<li>
<p>阻塞式select</p>
</li>
<li>
<p>避免 JDK 空轮询的 Bug</p>
<div class="paragraph">
<p>在 <code>NioEventLoop.run()</code> 方法中，每次轮询，都会记录一下轮询次数 <code>selectCnt</code>；在 <code>NioEventLoop.unexpectedSelectorWakeup(selectCnt)`方法中，如果轮询次数大于 `SELECTOR_AUTO_REBUILD_THRESHOLD</code>(该值默认是 <code>512</code>，可以通过 <code>io.netty.selectorAutoRebuildThreshold</code> 参数来改)，则重建。</p>
</div>
<div class="paragraph">
<p>重建工作在 <code>NioEventLoop.rebuildSelector()</code> 方法中完成，然后又委托给 <code>NioEventLoop.rebuildSelector0()</code> 来实际执行。主要工作就是创建一个新的 <code>selector</code>，然后把老的 <code>selector</code> 上的 <code>SelectionKey</code> 注册到新的 <code>selector</code> 上。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><code>processSelectedKeys()</code></strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>selected keySet 优化</p>
<div class="paragraph">
<p><code>SelectedSelectionKeySet</code> 底层是一个数组。只实现了增加操作，删除操作没有实现。为什么？</p>
</div>
</li>
<li>
<p><code>processSelectedKeysOptimized()</code></p>
<div class="paragraph">
<p><code>NioEventLoop.processSelectedKeysOptimized()</code>，重点在 <code>NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel)</code> 。</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_netty"><a class="anchor" href="#_netty"></a>4. Netty</h2>
<div class="sectionbody">
<div class="paragraph">
<p>创建 bossGroup 和 workerGroup
. 创建两个线程组 bossGroup 和 workerGroup
. bossGroup 只是处理连接请求，真正的客户端业务处理，会交给 workerGroup 完成
. 两个都是无限循环
. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数。默认 <code>CPU 内核数 * 2</code>，在 <code>io.netty.channel.MultithreadEventLoopGroup.DEFAULT_EVENT_LOOP_THREADS</code> 常量中定义</p>
</div>
<div class="sect2">
<h3 id="_异步任务"><a class="anchor" href="#_异步任务"></a>4.1. 异步任务</h3>
<div class="paragraph">
<p>比如这里我们有一个非常耗时长的业务&#8594; 异步执行 &#8594; 提交该 channel 对应的 NIOEventLoop 的 taskQueue 中, 从 ctx &#8594; pipeline &#8594; eventLoop &#8594; taskQueue 可以看到提交的任务。</p>
</div>
<div class="listingblock">
<div class="title">NettyServer</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty.simple;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import org.junit.jupiter.api.Test;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-06-27 17:28
 */
public class NettyServer {
  /**
   * 在 JDK 11 下启动错误： https://stackoverflow.com/a/57892679/951836
   */
  @Test
  public void server() throws InterruptedException {
    // 创建 bossGroup 和 workerGroup
    // 1. 创建两个线程组 bossGroup 和 workerGroup
    // 2. bossGroup 只是处理连接请求，真正的客户端业务处理，会交给 workerGroup 完成
    // 3. 两个都是无限循环
    // 4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数
    //    默认 CPU 内核数 * 2，在 io.netty.channel.MultithreadEventLoopGroup.DEFAULT_EVENT_LOOP_THREADS 常量中定义
    NioEventLoopGroup bossGroup = new NioEventLoopGroup(1);
    NioEventLoopGroup workerGroup = new NioEventLoopGroup();

    try {
      // 创建服务器端的启动对象，配置参数
      ServerBootstrap bootstrap = new ServerBootstrap();
      // 使用链式编程进行配置
      bootstrap.group(bossGroup, workerGroup) // 设置两个 线程组
        .channel(NioServerSocketChannel.class) // 使用 NioSocketChannel 作为服务器的通道实现
        .option(ChannelOption.SO_BACKLOG, 128) // 设置线程队列得到连接个数
        .childOption(ChannelOption.SO_KEEPALIVE, true) // 设置保持活动连接状态
        .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { // 创建一个通道测试对象
          // 给 pipeline 设置处理器
          @Override
          protected void initChannel(SocketChannel ch) throws Exception {
            ch.pipeline().addLast(new NettyServerHandler());
          }
        }); // 给 workerGroup 的 EventLoop 对应的管道设置处理器
      System.out.println("....服务器 is ready...");

      // 绑定一个端口并且同步，生成一个 ChannelFuture 对象
      // 启动服务器（并绑定端口）
      ChannelFuture future = bootstrap.bind(11911).sync();

      // 给 future 注册监听器
      future.addListener(new ChannelFutureListener() {
        @Override
        public void operationComplete(ChannelFuture future) throws Exception {
          if (future.isSuccess()) {
            System.out.println("监听端口 11911 成功");
          } else {
            System.out.println("监听端口 11911 失败");
          }
        }
      });


      // 对关闭通道进行监听
      future.channel().closeFuture().sync();

      // TODO Netty 的异步模型
    } finally {
      bossGroup.shutdownGracefully();
      workerGroup.shutdownGracefully();
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">NettyServerHandler</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty.simple;

import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

import java.util.concurrent.TimeUnit;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * 说明：
 * 我们自定义一个 Handler 需要继承 netty 规定好的某个 HandlerAdapter
 *
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-06-27 18:54
 */
public class NettyServerHandler extends ChannelInboundHandlerAdapter {
  /**
   * 读取数据实际（这里我们可以读取客户端发送的消息）
   *
   * @param ctx ChannelHandlerContext 上下文对象，含有管道 pipeline，通道 channel，地址
   * @param msg 客户端发送的数据，默认是 Object
   * @throws Exception
   */
  @Override
  public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

//    // 第一：正常情况
//    System.out.println("服务器读取线程 " + Thread.currentThread().getName());
//    System.out.println("server ctx = " + ctx);
//    System.out.println("看看 channel 和 pipeline 的关系");
//    // 从 ctx 可以拿到非常非常多的信息
//    Channel channel = ctx.channel();
//    ChannelPipeline pipeline = ctx.pipeline(); // 本质是一个双向链接
//
//    // 将 msg 转成一个 ByteBuf
//    // ByteBuf 是 Netty 提供的，不是 NIO 提供的 ByteBuffer
//    ByteBuf buf = (ByteBuf) msg;
//    System.out.println("客户端发送消息是：" + buf.toString(UTF_8));
//    System.out.println("客户端地址：" + channel.remoteAddress());


    // 第二种情况：
    // 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该 channel 对应的
    // NIOEventLoop 的 taskQueue 中,
    // 从 ctx -&gt; pipeline -&gt; eventLoop -&gt; taskQueue 可以看到提交的任务
    ctx.channel().eventLoop().execute(() -&gt; {
      try {
        Thread.sleep(20 * 1000);
        ctx.writeAndFlush(Unpooled.copiedBuffer("hello, 客户端~(&gt;^ω^&lt;)喵 2", UTF_8));
        System.out.println("channel code=" + ctx.channel().hashCode());
      } catch (Exception ex) {
        System.out.println("发生异常" + ex.getMessage());
      }
    });

    // 定时任务
    ctx.channel().eventLoop().schedule(() -&gt; {
      try {
        Thread.sleep(20 * 1000);
        ctx.writeAndFlush(Unpooled.copiedBuffer("hello, 客户端~(&gt;^ω^&lt;)喵 2", UTF_8));
        System.out.println("channel code=" + ctx.channel().hashCode());
      } catch (Exception ex) {
        System.out.println("发生异常" + ex.getMessage());
      }
    }, 10, TimeUnit.SECONDS);

    System.out.println(ctx);
  }

  /**
   * 数据读取完毕
   */
  @Override
  public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
    // 将数据写入到缓存，并刷新
    // 一般讲，我们对这个发送的数据进行编码
    ctx.writeAndFlush(Unpooled.copiedBuffer("Hello, D瓜哥~, pong -&gt; O(∩_∩)O哈哈~", UTF_8));
  }

  /**
   * 处理异常，一般需要关闭通道
   */
  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    ctx.close();
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">NettyClient</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty.simple;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import org.junit.jupiter.api.Test;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-06-27 19:35
 */
public class NettyClient {
  @Test
  public void client() throws InterruptedException {
    // 客户端只需要一个事件循环组即可
    NioEventLoopGroup group = new NioEventLoopGroup();

    try {
      // 创建客户端启动对象
      Bootstrap bootstrap = new Bootstrap();
      // 设置相关参数
      bootstrap.group(group) // 设置线程组
        .channel(NioSocketChannel.class) // 设置客户端通讯通道的实现类
        .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
          @Override
          protected void initChannel(SocketChannel ch) throws Exception {
            ch.pipeline().addLast(new NettyClientHandler()); // 加入自己的处理器
          }
        });
      System.out.println("....客户端 OK ...");

      // 启动客户端去连接服务器端
      // 关于 ChannelFuture 还要分析，涉及到 Netty 的异步模型
      ChannelFuture future = bootstrap.connect("127.0.0.1", 11911).sync();

      // 给关闭通道进行监听
      future.channel().closeFuture().sync();
    } finally {
      group.shutdownGracefully();
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">NettyClientHandler</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty.simple;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-06-27 19:41
 */
public class NettyClientHandler extends ChannelInboundHandlerAdapter {
    /**
     * 当通道就绪就会触发该方法
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("client " + ctx);
        ctx.writeAndFlush(Unpooled.copiedBuffer("Hello, D瓜哥，ping -&gt; \\(^o^)/", UTF_8));
    }

    /**
     * 当通道有读取事件时，会触发
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        System.out.println("");
        ByteBuf buf = (ByteBuf) msg;
        System.out.println("服务器回复的消息：" + buf.toString(UTF_8));
        System.out.println("服务器的地址：" + ctx.channel().remoteAddress());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Netty 的异步模型，就是基于 <code>ChannelFuture</code> 和 Listener 的监听回调模型。在入站、出站整个处理链上，可以注册各种各样的 Listener，以事件来驱动它们的调用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http"><a class="anchor" href="#_http"></a>4.2. HTTP</h3>
<div class="paragraph">
<p><code>io.netty.handler.codec.http.DefaultHttpRequest</code> 是 <code>io.netty.handler.codec.http.HttpObject</code> 的一个实现类。</p>
</div>
<div class="paragraph">
<p>为什么刷新一次浏览器，会有两个请求？ 浏览器增加了一次访问 ico 图标的请求。</p>
</div>
<div class="paragraph">
<p>HTTP 协议用完就关闭，所以，每次 pipeline 都不一样。跟 TCP 不太一样。</p>
</div>
<div class="listingblock">
<div class="title">TestServer</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty.http;


import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import org.junit.jupiter.api.Test;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-06-27 23:33
 */
public class TestServer {

  @Test
  public void test() throws InterruptedException {
    NioEventLoopGroup bossGroup = new NioEventLoopGroup(1);
    NioEventLoopGroup workerGroup = new NioEventLoopGroup();
    try {
      ServerBootstrap bootstrap = new ServerBootstrap();
      bootstrap.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .childHandler(new TestServerInitializer());

      ChannelFuture future = bootstrap.bind(11911).sync();

      future.channel().closeFuture().sync();
    } finally {
      bossGroup.shutdownGracefully();
      workerGroup.shutdownGracefully();
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">TestServerInitializer</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty.http;

import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.codec.http.HttpServerCodec;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-06-27 23:33
 */
public class TestServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; {
  @Override
  protected void initChannel(SocketChannel ch) throws Exception {
    // 向管道加入处理器
    // 得到管道
    ChannelPipeline pipeline = ch.pipeline();
    // 加入一个 Netty 提供的 HttpServerCodec
    // HttpServerCodec 的说明
    // 1. HttpServerCodec 是 Netty 提供的处理 HTTP 的编解码器
    pipeline.addLast("MyHttpServerCodec", new HttpServerCodec());
    // 2. 增加一个自定义的 Handler
    pipeline.addLast("MyTestServerHandler", new TestServerHandler());
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">TestServerHandler</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">package com.diguage.truman.netty.http;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpObject;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpVersion;

import java.net.URI;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * 说明
 * &lt;p&gt;
 * 1. SimpleChannelInboundHandler 就是 ChannelInboundHandlerAdapter 的子类
 * 2. HttpObject 客户端和服务器端相互同学的数据被封装成 HttpObject。
 *
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-06-27 23:33
 */
public class TestServerHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; {
  /**
   * 读取客户端数据
   */
  @Override
  protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
    // 判断 msg 是不是一个 HttpRequest 请求
    if (msg instanceof HttpRequest) {

      System.out.println("pipeline hashcode=" + ctx.pipeline().hashCode()
        + " TestServerHandler hash=" + this.hashCode());

      System.out.println("msg 类型 " + msg.getClass());
      System.out.println("客户端地址 " + ctx.channel().remoteAddress());

      HttpRequest httpRequest = (HttpRequest) msg;
      URI uri = new URI(httpRequest.uri());
      if ("/favicon.ico".equals(uri.getPath())) {
        System.out.println("请求了 favicon.ico，不做响应");
        return;
      }

      // 回复信息给浏览器(http协议)
      ByteBuf content = Unpooled.copiedBuffer("Hello, D瓜哥。我是服务器", UTF_8);
      FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);
      response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain");
      response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());

      // 将构建好的 response 返回
      ctx.writeAndFlush(response);
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-06-27 16:44:07 UTC
</div>
</div>
</body>
</html>