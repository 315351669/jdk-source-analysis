<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Netty</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="assets/css/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>p>code{color: #d14 !important;background-color: #f5f5f5 !important;border: 1px solid #e1e1e8;white-space: nowrap;border-radius: 3px;}</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_netty">1. Netty</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_netty"><a class="anchor" href="#_netty"></a>1. Netty</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_jdk_原生_socket_编程"><a class="anchor" href="#_jdk_原生_socket_编程"></a>1.1. JDK 原生 Socket 编程</h3>
<div class="paragraph">
<p>使用 JDK 原生的 Socket API 进行网络编程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.diguage.truman.netty;

import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.locks.LockSupport;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-04-21 14:31
 */
public class Test02 {
    public static final String HOST = "127.0.0.1";
    public static final int PORT = 11911;

    @Test
    public void testServer() {
        Server server = new Server(PORT);
        server.start();
        LockSupport.park();
    }

    @Test
    public void testClient() throws IOException {
        Socket socket = new Socket(HOST, PORT);
        new Thread(() -&gt; {
            System.out.println("客户端启动成功");
            while (true) {
                try {
                    String message = "Hello, D瓜哥！";
                    System.out.println("客户端发送数据：" + message);
                    socket.getOutputStream().write(message.getBytes(UTF_8));
                } catch (IOException e) {
                    System.out.println("写入数据报错！");
                    e.printStackTrace();
                }
                sleep();
            }
        }).start();
        LockSupport.park();
    }

    private void sleep() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static class Server {
        private ServerSocket serverSocket;

        public Server(int port) {
            try {
                this.serverSocket = new ServerSocket(port);
                System.out.println("服务端启动成功，端口号：" + port);
            } catch (IOException e) {
                System.out.println("服务端启动失败");
                e.printStackTrace();
            }
        }

        public void start() {
            new Thread(() -&gt; doStart()).start();
        }

        private void doStart() {
            while (true) {
                try {
                    Socket socket = serverSocket.accept();
                    new ClientHandler(socket).start();
                } catch (IOException e) {
                    System.out.println("服务端异常");
                    e.printStackTrace();
                }
            }
        }
    }

    private static class ClientHandler {
        public static final int MAX_DATA_LEN = 1024;
        private final Socket socket;

        public ClientHandler(Socket socket) {
            this.socket = socket;
        }

        public void start() {
            System.out.println("新客户端接入");
            new Thread(() -&gt; doStart()).start();
        }

        private void doStart() {
            try {
                InputStream inputStream = socket.getInputStream();
                while (true) {
                    byte[] data = new byte[MAX_DATA_LEN];
                    int len;
                    while ((len = inputStream.read(data)) != -1) {
                        String message = new String(data, 0, len);
                        System.out.println("客户端传来消息：" + message);
                        socket.getOutputStream().write(data);
                    }
                }
            } catch (IOException e) {
                System.out.println("服务端读取错误失败");
                e.printStackTrace();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>阻塞</p>
</li>
<li>
<p>高性能</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_server_startup"><a class="anchor" href="#_server_startup"></a>1.2. Server startup</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.diguage.truman.netty;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.util.AttributeKey;
import org.junit.Test;

import java.util.concurrent.locks.LockSupport;

/**
 * @author D瓜哥, https://www.diguage.com/
 * @since 2020-04-20 22:19
 */
public class Test03 {
    private static final int PORT = 11911;

    @Test
    public void testServer() throws InterruptedException {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childOption(ChannelOption.TCP_NODELAY, true)
                    .childAttr(AttributeKey.newInstance("childAttr"), null)
                    .handler(new ServerHandler())
                    .childHandler(new ChannelInitializer&lt;&gt;() {
                        @Override
                        protected void initChannel(Channel ch) throws Exception {

                        }
                    });
            ChannelFuture f = b.bind(PORT).sync();
            f.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
        LockSupport.park();
    }

    public static class ServerHandler extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
            System.out.println("channelRegistered");
        }

        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
            System.out.println("channelActive");
        }

        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            System.out.println("handlerAdded");
        }

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            super.channelRead(ctx, msg);
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个问题</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>服务端的 Socket 在哪里初始化？</p>
</li>
<li>
<p>在哪里 accept 连接？</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Netty 服务端启动</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建服务端 <code>Channel</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>io.netty.bootstrap.AbstractBootstrap.bind(int)</code></p>
</li>
<li>
<p><code>io.netty.bootstrap.AbstractBootstrap.doBind(SocketAddress)</code></p>
</li>
<li>
<p><code>io.netty.bootstrap.AbstractBootstrap.initAndRegister()</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>初始化服务端 <code>Channel</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>NioServerSocketChannel.NioServerSocketChannel()</code> 在 <code>NioServerSocketChannel</code> 默认初始化函数中，使用了 JDK 内置的 <code>SelectorProvider.provider()</code> 方法返回的 <code>SelectorProvider</code> 对象。</p>
</li>
<li>
<p>在 <code>NioServerSocketChannel.newSocket(SelectorProvider)</code> 方法中，调用 <code>provider.openServerSocketChannel()</code> 来创建 <code>ServerSocketChannel</code> 对象。</p>
</li>
<li>
<p>在 <code>AbstractNioChannel.AbstractNioChannel(Channel, SelectableChannel, int)</code> 构造函数中，设置 <code>selectableChannel.configureBlocking(false)</code>。</p>
</li>
</ol>
</div>
</li>
<li>
<p>注册 Selector</p>
</li>
<li>
<p>端口绑定&#8201;&#8212;&#8201;调用底层 API，实现对端口的绑定。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>服务端 <code>Channel</code> 初始化过程</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 <code>bind()</code> 进入</p>
</li>
<li>
<p><code>initAndRegister()</code></p>
</li>
<li>
<p>在 <code>AbstractBootstrap.initAndRegister()</code> 中通过 <code>channelFactory.newChannel()</code> 利用反射机制来创建 <code>Channel</code>。</p>
</li>
<li>
<p>在 <code>ServerBootstrap.init(Channel)</code> 中，初始化 <code>Channel</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>setChannelOptions</code></p>
</li>
<li>
<p><code>setAttributes</code></p>
</li>
<li>
<p>配置 <code>ChannelHandler</code>&#8201;&#8212;&#8201;配置服务端 pipeline。</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>初始化时，调用 <code>AbstractBootstrap.handler(io.netty.channel.ChannelHandler)</code>，配置 <code>ChannelHandler</code> 对象</p>
</li>
<li>
<p>通过调用 <code>AbstractBootstrap.initAndRegister()</code> 方法调用 <code>ServerBootstrap.init(Channel)</code> 方法，在其中，将 <code>ChannelHandler</code> 对象追加到 <code>Channel</code> 对象的 pipeline 的最后面。</p>
</li>
</ol>
</div>
</li>
<li>
<p>add <code>ServerBootstrapAcceptor</code></p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>上一步执行完毕后，在 <code>ServerBootstrap.init(Channel)</code> 方法中，会创建一个 <code>ServerBootstrapAcceptor</code> 对象添加到 pipeline 后面。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>注册 selector</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>AbstractChannel.AbstractUnsafe.register(EventLoop, ChannelPromise)</code> 入口</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>AbstractChannel.this.eventLoop = eventLoop;</code> 绑定线程</p>
</li>
<li>
<p><code>AbstractChannel.AbstractUnsafe.register0(ChannelPromise)</code> 实际注册</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p><code>AbstractChannel.doRegister()</code> 调用底层 JDK API 注册</p>
</li>
<li>
<p><code>pipeline.invokeHandlerAddedIfNeeded()</code></p>
</li>
<li>
<p><code>pipeline.fireChannelRegistered()</code></p>
<div class="paragraph">
<p>从示例代码的输出可以看出，<code>Test03.ServerHandler</code> 中三个"事件"方法被调用的顺序是： <code>handlerAdded</code>，<code>channelRegistered</code> 和 <code>channelActive</code>。</p>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>端口绑定</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>AbstractChannel.AbstractUnsafe.bind(SocketAddress, ChannelPromise)</code> 入口</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>AbstractBootstrap.doBind(SocketAddress)</code></p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p><code>javaChannel().bind()</code> JDK 底层绑定 <code>io.netty.channel.AbstractChannel.AbstractUnsafe.bind</code></p>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>` pipeline.fireChannelActive()` 传播事件</p>
</li>
</ol>
</div>
</li>
<li>
<p><code>HeadContext.readIfIsAutoRead()</code></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_nioeventloop"><a class="anchor" href="#_nioeventloop"></a>1.3. <code>NioEventLoop</code></h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>默认情况下，Netty 服务端起多少个线程？何时启动？</p>
</li>
<li>
<p>Netty 是如何解决 JDK 空轮询 Bug 的？</p>
</li>
<li>
<p>Netty 如何保证异步串行无锁化？</p>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>NioEventLoop</code> 创建</p>
</li>
<li>
<p><code>NioEventLoop</code> 启动</p>
</li>
<li>
<p><code>NioEventLoop</code> 执行逻辑</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_nioeventloop_创建"><a class="anchor" href="#_nioeventloop_创建"></a>1.3.1. <code>NioEventLoop</code> 创建</h4>
<div class="paragraph">
<p><code>NioEventLoop</code> 默认是在调用 <code>NioEventLoopGroup()</code> 时被创建，默认是 2 倍的 CPU 数量（由常量 <code>MultithreadEventLoopGroup.DEFAULT_EVENT_LOOP_THREADS</code> 来定义）。</p>
</div>
<div class="paragraph">
<p>在 <code>MultithreadEventExecutorGroup.MultithreadEventExecutorGroup(int, Executor, EventExecutorChooserFactory, Object&#8230;&#8203;)</code> 构造函数中：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建 <code>new ThreadPerTaskExecutor(newDefaultThreadFactory())</code> 线程池；</p>
<div class="paragraph">
<p>每次执行任务都会创建一个线程实体。</p>
</div>
<div class="paragraph">
<p><code>NioEventLoop</code> 线程命名规则 <code>nioEventLoop-1-XX</code>。在 <code>io.netty.util.concurrent.DefaultThreadFactory</code> 中可以看到。</p>
</div>
<div class="paragraph">
<p>这里还有两点需要注意：创建的线程对象和 <code>Runable</code> 被分别包装成了 <code>FastThreadLocalThread</code> 和 <code>FastThreadLocalRunnable</code>，主要是对 <code>ThreadLocal</code> 做了一些优化。</p>
</div>
</li>
<li>
<p>使用 <code>for</code> 循环，利用 <code>MultithreadEventExecutorGroup.newChild(Executor, Object&#8230;&#8203;)</code> 方法创建 <code>NioEventLoop</code> 对象。</p>
<div class="paragraph">
<p>有三个作用：①保存线程执行器 <code>ThreadPerTaskExecutor</code>；②创建一个 <code>MpscQueue</code>；③创建一个 selector。</p>
</div>
<div class="paragraph">
<p>在 <code>NioEventLoop.newTaskQueue(int)</code> 方法，然后调用 <code>NioEventLoop.newTaskQueue0(int)</code> 方法，创建 <code>MpscQueue</code>。</p>
</div>
</li>
<li>
<p>调用 <code>DefaultEventExecutorChooserFactory.newChooser(EventExecutor[])</code> 方法，创建线程选择器。</p>
<div class="paragraph">
<p><code>isPowerOfTwo()</code> 判断是否是 2 的幂，如果是则返回 <code>PowerOfTwoEventExecutorChooser</code>（优化），返回 <code>index &amp; (length - 1)`；否则返回 `GenericEventExecutorChooser`（普通），返回 `abs(index % length)</code>。</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_nioeventloop_启动"><a class="anchor" href="#_nioeventloop_启动"></a>1.3.2. <code>NioEventLoop</code> 启动</h4>
<div class="ulist">
<ul>
<li>
<p>服务端启动绑定接口</p>
</li>
<li>
<p>新连接接入，通过 choose 绑定一个 <code>NioEventLoop</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 <code>AbstractBootstrap.doBind0</code> 方法中，调用 <code>SingleThreadEventExecutor.execute(java.lang.Runnable)</code> 开始启动，再调用 <code>SingleThreadEventExecutor.execute(java.lang.Runnable, boolean)</code>，最后通过 <code>SingleThreadEventExecutor.startThread</code> 方法来启动。实际启动工作，最后委托给了 <code>SingleThreadEventExecutor.doStartThread</code> 方法来执行，这个方法中，调用 <code>SingleThreadEventExecutor.this.run();</code> 来启动 <code>NioEventLoop</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_nioeventloop_执行逻辑"><a class="anchor" href="#_nioeventloop_执行逻辑"></a>1.3.3. <code>NioEventLoop</code> 执行逻辑</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>run() &#8594; for(;;)</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>select()</code> 检查是否有 I/O 事件</p>
</li>
<li>
<p><code>processSelectedKeys()</code> 处理 I/O 事件</p>
</li>
<li>
<p><code>SingleThreadEventExecutor.runAllTasks(long)</code> 处理异步任务队列</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>select() 方法</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>deadline 以及任务穿插逻辑处理</p>
<div class="paragraph">
<p><code>NioEventLoop.select(long)</code></p>
</div>
</li>
<li>
<p>阻塞式select</p>
</li>
<li>
<p>避免 JDK 空轮询的 Bug</p>
<div class="paragraph">
<p>在 <code>NioEventLoop.run()</code> 方法中，每次轮询，都会记录一下轮询次数 <code>selectCnt</code>；在 <code>NioEventLoop.unexpectedSelectorWakeup(selectCnt)`方法中，如果轮询次数大于 `SELECTOR_AUTO_REBUILD_THRESHOLD</code>(该值默认是 <code>512</code>，可以通过 <code>io.netty.selectorAutoRebuildThreshold</code> 参数来改)，则重建。</p>
</div>
<div class="paragraph">
<p>重建工作在 <code>NioEventLoop.rebuildSelector()</code> 方法中完成，然后又委托给 <code>NioEventLoop.rebuildSelector0()</code> 来实际执行。主要工作就是创建一个新的 <code>selector</code>，然后把老的 <code>selector</code> 上的 <code>SelectionKey</code> 注册到新的 <code>selector</code> 上。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><code>processSelectedKeys()</code></strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>selected keySet 优化</p>
<div class="paragraph">
<p><code>SelectedSelectionKeySet</code> 底层是一个数组。只实现了增加操作，删除操作没有实现。为什么？</p>
</div>
</li>
<li>
<p><code>processSelectedKeysOptimized()</code></p>
<div class="paragraph">
<p><code>NioEventLoop.processSelectedKeysOptimized()</code>，重点在 <code>NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel)</code> 。</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-04-30 10:46:16 +0800
</div>
</div>
</body>
</html>